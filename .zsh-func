#!/bin/zsh

function \?() {
echo «$(\date +"%Y%m%d %H%M%S.%N%::z%Z %A")»
prntenv
#https://www.youtube.com/playlist?list=PLypxmOPCOkHXL8TuVKiDChkTH32MfLr7S
#https://www.youtube.com/watch?v=fDoYwL90WUg&list=PLS1QulWo1RIaJECMeUT4LFwJ-ghgoSH6n&index=8
#https://youtu.be/oYtGrCP_n0k?t=329
#https://www.youtube.com/watch?v=VPInIrd5Hqc#t=35s
#https://www.youtube.com/watch?v=M8Bd7uHH4Yg&feature=youtu.be
#https://codek.tv/v/6MaOPdQPvow
#http://video.ch9.ms/ch9/3306/0e92ae7f-7b06-4a08-a2a0-e80545733306/DefragTools179_high.mp4
#https://video.xx.fbcdn.net/v/t43.1792-2/14018597_941915082602721_1324838905_n.mp4?efg=eyJybHIiOjE1MDAsInJsYSI6MTAyNCwidmVuY29kZV90YWciOiJzdmVfaGQifQ%3D%3D&rl=1500&vabr=588&oh=37f5d4bd4e3b3de99d2f0093c17a69d0&oe=57CBD2F3
#https://www.facebook.com/ehbichig/videos/991876094204055/

#use variables to hold regxprs to avoid: parse error near `&'
#"dl+"(echo "$url" >> dllst for url in "$@") automatically escape ? and = in output file! e.g. https://www.youtube.com/playlist\?list\=PLKK11Ligqitg9MOX3-0tFT1Rmh3uJp7kA
#utvList_regxpr="^https?://(www\.)?youtu\.?be(\.com)?/playlist[\]?\?list[\]?=[-_a-zA-Z0-9]+$"
local utvList_regxpr="^https?://(www\.)?youtu\.?be(\.com)?/playlist\\\\?\?list\\\\?=[-_a-zA-Z0-9]+$"
#utvSingl_regxpr="^https?://(www\.)?youtu\.?be(\.com)?/(watch\?v=)?[-_a-zA-Z0-9]+([\&#]list=[-_.a-zA-Z0-9]+)?([-_.a-zA-Z0-9\&#=]+)*$"
local utvSingl_regxpr="^https?://(www\.)?youtu\.?be(\.com)?/(watch\?v=)?[-_a-zA-Z0-9]+([\&#]list=[-_.a-zA-Z0-9]+)?[-_.a-zA-Z0-9\&#=]*$"
local codek_regxpr="^https?://(www\.)?codek\.tv/v/[-_a-zA-Z0-9]+$"
local knl9_regxpr="^https?://video\.ch9\.ms/[-_a-zA-Z0-9/.]+[-_a-zA-Z0-9.]+$"
local vimeo_regxpr="^https?://(www\.)?vimeo\.com/[-_a-zA-Z0-9]+$"
local facebook_regxpr="^https?://video\.[.a-zA-Z0-9]*fbcdn\.net/v/[-_.a-zA-Z0-9]+/[-_.a-zA-Z0-9]+(mp4|webm|mkv)[-_.a-zA-Z0-9?%=&]*$"
local idx=0

local audiofrmt="(mp3|flac|m4a|opus|aac|wav)"
local videofrmt="(mp4|mkv|webm|mpg|mpeg|m2ts|MTS|CPI|clpi|MPL|mpls|BDM|bdmv|rmvb|avi|dvi|ogg)"

#1 input sanitization
#local uniq_args=$(gawk 'BEGIN {RS=" ";ORS="\n"} !seen[$1]++ {printf "%s\n", $1}' <<< "$@")
local uniq_args=$(gawk 'BEGIN {RS=" ";ORS="\n"} !seen[$1]++ {print $1}' <<< "$@")
#local uniq_args=$(gawk 'BEGIN {RS=ORS=" "} !seen[$1]++ {print $1}' <<< "$@")
echo '(trace):uniq_args:['$uniq_args']'

local cmd='sudo find /mnt/0 ~ -xdev -type f \( '

#https://unix.stackexchange.com/questions/275794/iterating-over-multiple-line-string-stored-in-variable
#https://superuser.com/questions/284187/bash-iterating-over-lines-in-a-variable
local str=""
#IFS=' ' read -a str_array <<< "$@"	#bad option: -a
#for str in "${str_array[@]}";do	#unnecessary because of cmd="\? $urls_whitespaced" && eval " $cmd"

#http://www.refining-linux.org/archives/38/ZSH-Gem-3-No-automatic-word-split/
#https://unix.stackexchange.com/questions/128985/why-not-parse-ls
setopt sh_word_split
setopt SH_WORD_SPLIT
#local IFS='
#'
local IFS=$'\n'
#local IFS=' '
for str in $uniq_args;do
#todo: treat quoted string as single arg e.g. ? "Clean C++"
#for str in $@;do
#trim spaces at both ends
#	str="${str##( |\t|\f|\v)}"
#	str="${str%%( |\t|\f|\v)}"
#	str=$(tr -s "[:blank:]" <<<$str)
	str=$(tr -s " \t\f\v" <<< $str)

	#https://stackoverflow.com/questions/369758/how-to-trim-whitespace-from-a-bash-variable
	str=$(trmsp $str)
    	echo "(trace):input arg after func trmsp() called:[$str]"

	if [[ $str =~ $utvList_regxpr ]];then
		echo "(trace):[$str] match [$utvList_regxpr]"
		echo '$'$((++idx)):'['$str']'
		echo "playlist (contained) item(s) search is currently not supported!"
		continue
	elif [[ $str =~ $utvSingl_regxpr ]];then
#		echo "(trace):[$str] match [$utvSingl_regxpr]"
		str="${str##*youtu*be*/}"
		str="${str##watch\?v=}"
		str="${str%% *}"
	elif [[ $str =~ $codek_regxpr ]];then
		echo "(trace):[$str] match [$codek_regxpr]"
		str="${str##*codek.tv/v/}"
	elif [[ $str =~ $knl9_regxpr ]];then
		echo "(trace):[$str] match [$knl9_regxpr]"
		str="${str##*video.ch9.ms/[-_a-zA-Z0-9/.]*/}"
	elif [[ $str =~ $vimeo_regxpr ]];then
		echo "(trace):[$str] match [$vimeo_regxpr]"
		str="${str##*vimeo.com/}"
	elif [[ $str =~ $facebook_regxpr ]];then
		echo "(trace):[$str] match [$facebook_regxpr]"
#		str="${str##*video.*fbcdn.net/v/[-_.a-zA-Z0-9]*/}"
		str="${str##*video.*fbcdn.net/v/*/}"
	else
		echo '$'$((++idx)):'['$str']'
	fi
	str="${str%&index=*}"
	str="${str%&list=*}"
	str="${str%&t=*}"
	str="${str%%\?*}"
	str="${str%%&*}"
	str="${str%%#*}"

#replace spaces inside with *
#	str="${str// \t\f\v/*}"
	str="${str// /*}"

#strip extension except .todo
#https://fileinfo.com/filetypes/common
#	str="${str%?\.(mp4|mp3|mkv|mpg|mpeg|webm|m4a|aac|flac|rmvb|avi|opus|dvi|wav)}"  #?:non greedy
	str="${str%\.audiofrmt}"
	str="${str%\.videofrmt}"
	cmd+="-iname \"*$str*\" -o "
done

#http://www.refining-linux.org/archives/38/ZSH-Gem-3-No-automatic-word-split/
unsetopt sh_word_split
unsetopt SH_WORD_SPLIT

if [[ $cmd =~ -iname ]];then
	cmd=${cmd% -o }
	cmd+=' \) -exec ls -alFt {} \;'
#	cmd+=" \) -exec ls -alFt {} \; | gawk -F'.' '{print substr($(NF-1),length($(NF-1))-4)}' > $dnldd_file"  #zsh: NF-1: command not found...
	echo '(trace):$cmd(\?(){}):['$cmd']'

	#find $uniq_args in other "download list files", save only when not downloaded and not listed in other download list files!
	local url_NoEscapeBraces="[a-zA-Z0-9]+\.[a-zA-Z0-9]{2,3}/[a-zA-Z0-9]+"
	local url_EscapeBraces="[a-zA-Z0-9]+\.[a-zA-Z0-9]\{2,3\}/[a-zA-Z0-9]+"
	#todo: jump statement in shell script  #unnecessary because of if(... && ...) || (... && ...)
	#if [[ $uniq_args =~ $url_NoEscapeBraces ]];then
	if ([[ $uniq_args =~ $url_EscapeBraces ]] && echo "(trace):match regxpr \`$url_EscapeBraces' in args") || ([[ $uniq_args =~ $url_NoEscapeBraces ]] && echo "(trace):match regxpr \`$url_NoEscapeBraces' in args");then
	#	echo "(trace):match regxpr \`$url_NoEscapeBraces' in args"

		#todo: save and resume partially downloaded files, e.g. ".part" files
		local dnldd_file="/tmp/_downloaded.find_avfiles_"
	#	eval " $cmd" | gawk -F'.' '{print substr($(NF-1),length($(NF-1))-4)}' > "$dnldd_file"
		eval " $cmd" | tee "$dnldd_file" 2>&1

	#	echo -e '(trace):ID(last 5 char of names\x27 main part) of already downloaded:'
	#	more "$dnldd_file"
		echo '(trace):$(echo -n $uniq_args | wc -l)':$(echo -n $uniq_args | wc -l)
		echo '(trace):$(echo $uniq_args | wc -l)':$(echo $uniq_args | wc -l)
		echo '(trace):$(wc -l <<< $uniq_args)':$(wc -l <<< $uniq_args)
		#https://unix.stackexchange.com/questions/343053/bash-test-wc-with-ge-division-by-0-error/343055
		#echo '(trace):$(wc -l "$dnldd_file")':$(wc -l "$dnldd_file")  #LnNum filename
		echo '(trace):$(wc -l < "$dnldd_file")':$(wc -l < "$dnldd_file")
		if (( $(wc -l < "$dnldd_file") < $(wc -l <<< $uniq_args) ));then
	#	if (( $(wc -l "$dnldd_file") < $(wc -l <<< $uniq_args) ));then  #?:LnNum: division by zero
	#	if (( $(wc -l "$dnldd_file") < $(echo -n $uniq_args | wc -l) ));then  #?:LnNum: division by zero
			echo '(trace):$(wc -l < "$dnldd_file") < $(wc -l <<< $uniq_args):true'
			local dnldd_ID="/tmp/_downloaded_ID.find_avfiles_"
			local dllst_file="dllst"

			#todo: hard to extract ideal safe common substr
			gawk -F'.' '{print substr($(NF-1),length($(NF-1))-4)}' "$dnldd_file" > "$dnldd_ID"
			
			#todo: find other "download list file", diff and save entries only in $uniq_args
			command grep -v -F -f "$dnldd_ID" <<< $uniq_args > /tmp/_not_downloaded.find_avfiles_
			
			echo -e '$(sudo find /mnt/0 ~ -xdev -type f -iname $dllst_file -printf \x27%p \x27):['$(sudo find /mnt/0 ~ -xdev -type f -iname $dllst_file -printf '%p ')']'

			#https://unix.stackexchange.com/questions/386499/how-to-check-if-file-is-empty-or-it-has-only-blank-characters
			#command grep -q '[^ \t\v\n\u3000]' $(sudo find /mnt/0 ~ -xdev -type f -iname $dllst_file -printf '%p ') && {  #(
			local spaces_rexpr='^[ \t\v\n\u3000]*$'
			local dllstfiles=$(sudo find /mnt/0 ~ -xdev -type f -iname $dllst_file -printf '%p ')
			if [[ -n $dllstfiles ]];then
				echo '(trace):[[ -n $dllstfiles ]]:true'
			fi

			if [[ ! $dllstfiles =~ $spaces_rexpr ]];then
				echo '(trace):[[ ! $dllstfiles =~ $spaces_rexpr ]]:true'
			fi

			#if [[ -n $dllstfiles ]] && [[ ! $dllstfiles =~ $spaces_rexpr ]];then
			if [[ ! $dllstfiles =~ $spaces_rexpr ]];then
				cat -n $dllstfiles | sort -k2 -k1n | uniq -f1 | sort -nk1,1 | cut -f2- > /tmp/_not_downloaded_but_listed_in_dllst_files.find_avfiles_
				command grep -v -F -f /tmp/_not_downloaded_but_listed_in_dllst_files.find_avfiles_  /tmp/_not_downloaded.find_avfiles_ > "$dllst_file"

#https://stackoverflow.com/questions/32126653/how-does-end-work-in-bash-to-create-a-multi-line-comment-block?noredirect=1&lq=1
: <<'HEREDOC:BLOCK_COMMENT'
				#command grep -v -F -f /tmp/_tmp2_ <<< $(sudo find /mnt/0 ~ -xdev -type f -iname $dllst_file -printf '%p ') > /tmp/_tmp3_
				#command grep -v -F -f /tmp/_tmp2_ $(sudo find /mnt/0 ~ -xdev -type f -iname $dllst_file -printf '%p ') > /tmp/_tmp3_
				#1 #erroneous: file name interpreted as literal string
				echo 'eval $(command grep -v -F -f /tmp/_tmp2_ <<< $(sudo find /mnt/0 ~ -xdev -type f -iname $dllst_file -printf \x27%p \x27) > /tmp/_tmp31_) : /tmp/_tmp31_ :'
				eval $(command grep -v -F -f /tmp/_tmp2_ <<< $(sudo find /mnt/0 ~ -xdev -type f -iname $dllst_file -printf '%p ') > /tmp/_tmp31_)
				echo "[$(more /tmp/_tmp31_)]"
				
				#2
				echo 'eval $(command grep -v -F -f /tmp/_tmp2_ $(trmsp $(sudo find /mnt/0 ~ -xdev -type f -iname $dllst_file -printf \x27%p \x27)) > /tmp/_tmp32_) : /tmp/_tmp32_ :'
				eval $(command grep -v -F -f /tmp/_tmp2_ $(trmsp $(sudo find /mnt/0 ~ -xdev -type f -iname $dllst_file -printf '%p ')) > /tmp/_tmp32_)
				echo "[$(more /tmp/_tmp32_)]"
				
				#3 #erroneous: file name interpreted as literal string
				echo 'eval command grep -v -F -f /tmp/_tmp2_ <<< $(sudo find /mnt/0 ~ -xdev -type f -iname $dllst_file -printf \x27%p \x27) > /tmp/_tmp33_ : /tmp/_tmp33_ :'
				eval command grep -v -F -f /tmp/_tmp2_ <<< $(sudo find /mnt/0 ~ -xdev -type f -iname $dllst_file -printf '%p ') > /tmp/_tmp33_
				echo "[$(more /tmp/_tmp33_)]"
				
				#4
				echo 'eval command grep -v -F -f /tmp/_tmp2_ $(trmsp $(sudo find /mnt/0 ~ -xdev -type f -iname $dllst_file -printf \x27%p \x27)) > /tmp/_tmp34_ : /tmp/_tmp34_ :'
				eval command grep -v -F -f /tmp/_tmp2_ $(trmsp $(sudo find /mnt/0 ~ -xdev -type f -iname $dllst_file -printf '%p ')) > /tmp/_tmp34_
				echo "[$(more /tmp/_tmp34_)]"
				#find: paths must precede expression: x27
				#Usage: find [-H] [-L] [-P] [-Olevel] [-D help|tree|search|stat|rates|opt|exec] [path...] [expression]
				#echo 'eval $(echo -en $(trmsp $(sudo find /mnt/0 ~ -xdev -type f -iname $dllst_file -printf \x27%p \x27)) | command grep -v -F -f /tmp/_tmp2_ > /tmp/_tmp3_) : /tmp/_tmp3_ :'
				#eval $(echo -en $(trmsp $(sudo find /mnt/0 ~ -xdev -type f -iname $dllst_file -printf \x27%p \x27)) | command grep -v -F -f /tmp/_tmp2_ > /tmp/_tmp3_)
				#more /tmp/_tmp3_

				#https://unix.stackexchange.com/questions/386499/how-to-check-if-file-is-empty-or-it-has-only-blank-characters
				command grep -q '[^ \t\v\n\u3000]' /tmp/_tmp34_ && (
					#command mv -f /tmp/_tmp34_ "$dllst_file"
					#command cp -i /tmp/_tmp34_ "$dllst_file"
					#cat /tmp/_tmp34_ >> "$dllst_file"
				)
HEREDOC:BLOCK_COMMENT
			else
				#unnecessary because gotten from $uniq_args
				#cat -n /tmp/_not_downloaded.find_avfiles_ | sort -k2 -k1n | uniq -f1 | sort -nk1,1 | cut -f2- > "$dllst_file"
				command mv -f /tmp/_not_downloaded.find_avfiles_ "$dllst_file"
			fi
			#} #)

			echo -e "(trace):download list:file \x22$dllst_file\x22:"
			more "$dllst_file"
		fi
	else
		echo '(trace):$cmd(\?(){}):['$cmd']'

		#http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#eval
		#The eval utility shall construct a command by concatenating arguments together, separating each with a <space> character. The constructed command shall be read and executed by the shell.
		#SYNOPSIS:eval [argument...]
		#Since eval is not required to recognize the "--" end of options delimiter, in cases where the argument(s) to eval might begin with '-' it is recommended that the first argument is prefixed by a string that will not alter the commands to be executed, such as a <space> character:
		#eval " $commands"
		#or:
		#eval " $(some_command)"
		eval " $cmd"
	fi
	echo '$?':$?
else
	return 113 #can't be passed on to outer/upper levels!
fi
echo «$(\date +"%Y%m%d %H%M%S.%N%::z%Z %A")»
}

function dnldck() {
echo «$(\date +"%Y%m%d %H%M%S.%N%::z%Z %A")»
local urls_whitespaced=""
local errmsg="[fF]ind.*[pP]ermission[s ]*[dD]enied"	#use variable to hold complex regxpr!
local dllst_file="dllst"

while getopts "t" opt; do
	case "$opt" in
	t) dllst_file="dllst*";;
	\?) # unknown flag
		#echo >&2 \
		echo "usage: $0 [-t]"
		return 1;;
	*) echo "default case of getopts, nothing special.";;
	esac
done
shift $((OPTIND-1))

#Note: For those dealing with CJK text (Chinese, Japanese, and Korean), the double-byte space (Unicode \u3000) is not included in \s for any implementation I've tried so far (Perl, .NET, PCRE, Python). You'll need to either normalize your strings first (such as by replacing all \u3000 with \u0020), or you'll have to use a character set that includes this codepoint in addition to whatever other whitespace you're targeting, such as [ \t\u3000].
#https://stackoverflow.com/questions/3583111/regular-expression-find-spaces-tabs-space-but-not-newlines
local blankline_rexpr="^[ \t\v\u3000]*$"
local file=""
for file in $(sudo find /mnt/0 ~ -xdev -type f -iname $dllst_file);do
#	if [[ ! ( $file =~ [fF]ind.*[pP]ermission[s ]*[dD]enied ) ]];then	#error: condition expected: $file	#stderr inaccessible this way!
	if [[ ! $file =~ $errmsg && -f $file ]];then	#stderr inaccessible this way!
		cat -n $file | sort -k2 -k1n | uniq -f1 | sort -nk1,1 | cut -f2- > _tmp.dnldck_ && command mv -f _tmp.dnldck_ $file
		echo $file:
		more $file
	#while read -r line;do
	#	if [[ ! $line =~ $blankline_rexpr ]];then
	#		urls_whitespaced+="\"$line\" "	#urls_whitespaced+=("$line"+" ")?
	#		#urls_whitespaced+="$line "	#urls_whitespaced+=("$line"+" ")?
	#	fi
	#done < "$file"
	#echo '$urls_whitespaced:['$urls_whitespaced']'
	#IFS=' ' read -a urls_whitespaced_arr <<<"$urls_whitespaced"	#bad option: -a
	#\? "$urls_whitespaced_arr"	#wrong!
	#\? $urls_whitespaced	#wrong!
	#cmd="\? $urls_whitespaced"
	#cmd="\? $(gawk -v quot="'" '!seen[toupper($0)]++ {printf "%s%s%s ", quot, $0, quot} END {print ""}' $file)"
	local cmd="\? $(gawk -v quot="'" '!seen[$0]++ {printf "%s%s%s ", quot, $0, quot}' $file)"
	
	#https://unix.stackexchange.com/questions/102008/how-do-i-trim-leading-and-trailing-whitespace-from-each-line-of-some-output
	#shopt -s extglob  #setopt: no such option: extglob
	#cmd=${cmd##+([[:space:]])}
	#cmd=${cmd%%+([[:space:]])}
	cmd=${cmd##[[:space:]]}
	cmd=${cmd%%[[:space:]]}
	echo '(trace):cmd(dnldck(){}):['$cmd']'
	eval " $cmd"
#	urls_whitespaced=""
	fi
done
echo '$?':$?
echo «$(\date +"%Y%m%d %H%M%S.%N%::z%Z %A")»
}

#append to todo file
function +() {
if (($# > 0));then
	#Don't quote args
	#WARNING: The url doesn't specify the protocol, trying with http
	#[generic] watch?v=B2XtqVZcSdM': Requesting header
	#WARNING: Could not send HEAD request to http://'https://www.youtube.com/watch?v=B2XtqVZcSdM': <urlopen error [Errno -2] Name or service not known>
	#[generic] watch?v=B2XtqVZcSdM': Downloading webpage
	#ERROR: Unable to download webpage: <urlopen error [Errno -2] Name or service not known> (caused by URLError(gaierror(-2, 'Name or service not known'),))
	#local uniq_args=$(gawk -v quot="'" 'BEGIN {RS=ORS="\n"} !seen[$0]++ {printf "%s%s%s\n", quot, $0, quot}' <<< "$@")
	local uniq_args=$(gawk 'BEGIN {RS=ORS=" "} !seen[$1]++ {print $1} END {print "\n"}' <<< "$@")
	echo '(trace):uniq_args before func trmsp() called:['$uniq_args']'
	uniq_args=$(trmsp $uniq_args)
	echo '(trace):uniq_args after func trmsp() called:['$uniq_args']'
	local outfile="/mnt/0/gthb/note/.todo"
	echo '(trace):outfile:['$outfile']'
	echo "$uniq_args" >> "$outfile"
	#https://unix.stackexchange.com/questions/194780/remove-duplicate-lines-while-keeping-the-order-of-the-lines
	cat -n < "$outfile" | sort -k2 -k1n | uniq -f1 | sort -nk1,1 | cut -f2- > _tmp.todo_ && command mv -f _tmp.todo_ "$outfile"

	echo '$?':$?
fi
}

#append to youtube download file
function dl+() {
if (($# > 0));then
	local dllst_file="dllst"
	#Don't quote args
	#WARNING: The url doesn't specify the protocol, trying with http
	#[generic] watch?v=B2XtqVZcSdM': Requesting header
	#WARNING: Could not send HEAD request to http://'https://www.youtube.com/watch?v=B2XtqVZcSdM': <urlopen error [Errno -2] Name or service not known>
	#[generic] watch?v=B2XtqVZcSdM': Downloading webpage
	#ERROR: Unable to download webpage: <urlopen error [Errno -2] Name or service not known> (caused by URLError(gaierror(-2, 'Name or service not known'),))

	#local uniq_args=$(gawk -v quot="'" 'BEGIN {RS=" "} !seen[toupper($1)]++ {printf "%s%s%s\n", quot, $1, quot} END {print ""}' <<< "$@")
	local uniq_args=$(gawk 'BEGIN {RS=" ";ORS="\n"} !seen[$1]++ {print $1}' <<< "$@")
	echo '(trace):uniq_args before func trmsp() called:['$uniq_args']'
	uniq_args=$(trmsp $uniq_args)
	echo '(trace):uniq_args after func trmsp() called:['$uniq_args']'

	if [[ -f $dllst_file ]];then
	#	gawk '!seen[toupper($0)]++{exit 1}' $dllst_file || (
	#		echo 'dl+(){} found duplicate lines, remove duplicates now.'
	#		gawk '!seen[toupper($0)]++' $dllst_file > _tmp.dnld_append_ && command mv -f _tmp.dnld_append_ $dllst_file
	#		)

		cat -n <<< $uniq_args | sort -k2 -k1n | uniq -f1 | sort -nk1,1 | cut -f2- > _tmp.dnld_append_ && command mv -f _tmp.dnld_append_ $dllst_file
		#https://unix.stackexchange.com/questions/194780/remove-duplicate-lines-while-keeping-the-order-of-the-lines
		#https://unix.stackexchange.com/questions/39291/run-a-command-that-is-shadowed-by-an-alias

	#	local IFS=$'\n'
	#	local url=""
	#	for url in "$uniq_args";do
	#	#	url="${url%&list=*}"
	#	#	url="${url%&index=*}"
	#		command grep -F "$url" $dllst_file || echo "$url" >> $dllst_file
	#		#command grep -qF "$url" $dllst_file || echo "$url" >> $dllst_file
	#	done

	#https://stackoverflow.com/questions/46408707/fastest-way-appending-a-line-to-a-file-only-if-it-does-not-already-exist
	#	gawk 'FNR==NR {uniq_args[$0]; next}
	#		$0 in uniq_args{delete uniq_args[$0]}
	#		1
	#		END{for (line in uniq_args) print line >> FILENAME}' <<< $uniq_args $dllst_file
	else
	#	gawk -v quot="'" 'BEGIN {RS=" ";ORS="\n"} !seen[toupper($1)]++ {printf "%s%s%s\n", quot, $1, quot}' <<< $uniq_args >> $dllst_file
		gawk 'BEGIN {RS=ORS="\n"} !seen[$0]++ {print $0}' <<< "$uniq_args" >> $dllst_file  #already quoted in $uniq_args
	fi

	#	gawk -v quot="'" 'BEGIN {RS=" ";ORS="\n"} !seen[toupper($1)]++ {printf "%s%s%s\n", quot, $1, quot}' <<< "$@" >> $dllst_file
	#	gawk -v quot="'" 'BEGIN {RS=" ";ORS="\n"} !seen[toupper($0)]++{printf "%s%s%s\n", quot, $0, quot}' <<< "$@" >> $dllst_file  #last line won't be appended with spaces, so always unique, hence faulty!
	#	gawk 'BEGIN {IRS=" ";ORS="\n"} !seen[toupper($0)]++ END {print ""}' <<< "$@" >> $dllst_file
	#							 ^ syntax error
	echo '$?':$?
fi
}

function 0() {
if (($# > 0));then
	#$(gawk -v quot="'" 'BEGIN {RS=" "} !seen[$1]++ {print quot$1quot}' <<< "$@")
	local uniq_args=$(gawk -v quot="'" 'BEGIN {RS=" ";ORS="\n"} !seen[$1]++ {printf "%s%s%s\n", quot, $1, quot}' <<< "$@")
	echo '(trace):uniq_args before func trmsp() called:['$uniq_args']'
	uniq_args=$(trmsp $uniq_args)
	echo '(trace):uniq_args after func trmsp() called:['$uniq_args']'
	local IFS=$'\n'
	local file=""
	for file in "$uniq_args";do
		if [[ -f $file ]];then
			command mv -f "$file" "$file.bk"
			echo -n > "$file"
		fi
	done
	echo '$?':$?
fi
}

function utlsfrm() {
if (($# > 0));then
#	local uniq_args=$(gawk -v quot="'" 'BEGIN {RS=" ";ORS="\n"} !seen[toupper($1)]++ {printf "%s%s%s\n", quot, $1, quot} END {print ""}' <<< "$@")
	local uniq_args=$(gawk 'BEGIN {RS=ORS=" "} !seen[$1]++ {print $1}' <<< "$@")
	echo '(trace):uniq_args before func trmsp() called:['$uniq_args']'
	uniq_args=$(trmsp $uniq_args)
	echo '(trace):uniq_args after func trmsp() called:['$uniq_args']'
setopt sh_word_split
setopt SH_WORD_SPLIT
	local IFS=$'\n'
	local url=""
	for url in "$uniq_args";do
		youtube-dl --youtube-skip-dash-manifest --prefer-ffmpeg --list-formats $url
	done
unsetopt sh_word_split
unsetopt SH_WORD_SPLIT
#	youtube-dl --youtube-skip-dash-manifest --list-formats $uniq_args  #only first arg get handled
	echo '$?':$?
fi
}

function dprx() {
if (($# > 0));then
	local uniq_args=$(gawk -v quot="\"" 'BEGIN {RS=" ";ORS="\n"} !seen[$1]++ {printf "%s%s%s\n", quot, $1, quot}' <<< "$@")
	echo '(trace):uniq_args before func trmsp() called:['$uniq_args']'
	uniq_args=$(trmsp $uniq_args)
	echo '(trace):uniq_args after func trmsp() called:['$uniq_args']'

setopt sh_word_split
setopt SH_WORD_SPLIT
	local arg=""
	local IFS=$'\n'
	for arg in "$uniq_args";do
		#if [[ $arg =~ ^(http|HTTP)s?$ ]];then
		if [[ $arg =~ (http|HTTP)s? ]];then
			echo '(trace):$arg:['$arg'] hit regex =~ (http|HTTP)[s]?'
			unset http_proxy
			unset HTTP_PROXY
		#elif [[ $arg =~ ^(ftp|FTP)$ ]];then
		elif [[ $arg =~ (ftp|FTP) ]];then
			echo '(trace):$arg:['$arg'] hit =~ (ftp|FTP)'
			unset ftp_proxy
			unset FTP_PROXY
		#elif [[ $arg =~ ^(sock|SOCK).*$ ]];then
		elif [[ $arg =~ (sock|SOCK).* ]];then
			echo '(trace):$arg:['$arg'] hit =~ (sock|SOCK).*'
			unset socks_proxy
			unset SOCKS_PROXY
		else
			echo '(trace):$arg:['$arg'] unrecognized protocol!'
		fi
	done
unsetopt sh_word_split
unsetopt SH_WORD_SPLIT
fi
prprx
}

function prprx() { 
echo "http_proxy:[$http_proxy]"
echo "https_proxy:[$https_proxy]"
echo "ftp_proxy:[$ftp_proxy]"
echo "socks_proxy:[$socks_proxy]"
echo "no_proxy:[$no_proxy]"
echo "HTTP_PROXY:[$HTTP_PROXY]"
echo "HTTPS_PROXY:[$HTTPS_PROXY]"
echo "FTP_PROXY:[$FTP_PROXY]"
echo "SOCKS_PROXY:[$SOCKS_PROXY]"
echo "NO_PROXY:[$NO_PROXY]"
}

function --() {
rm -rf ~/.Trash ~/.thumbnails ~/.Thumbnails ~/.local/share/Trash ~/.local/share/trash 
sudo find /var/cache/PackageKit/ -name "*.rpm" -execdir rm {} \; #probably Fedora only
sudo dnf autoremove #many times faultily automatically remove kernel-modules-extra which will be reinstalled on next system upgrade!
#sudo apt autoremove -y; sudo apt autoclean; sudo apt clean
#E: encountered a section with no package: header
#E: problem with Mergelist/var/lib/apt/lists
#sudo rm -Rf /var/lib/apt/lists/* -vf
echo '$?':$?
}

function upgrlog() {
#todo:
#⓪ display systemd upgrade cmd/script log: failed to get non-admin user and root systemd service to run OS update cmd/script while SELinux is enforced!
#① display cron job upgrade cmd/script log: unfavorable and inflexible because system login event is undeterministic! 
if [[ -f /var/log/sys_upgrade.log ]];then
	less /var/log/sys_upgrade.log
elif [[ -f /var/log/youtube-dl_upgrade.log ]];then
	less /var/log/youtube-dl_upgrade.log
fi
}

function vln() {
local uniq_args=$(gawk 'BEGIN {RS=" ";ORS="\n"} !seen[$1]++ {print $1}' <<< "$@")
echo '(trace):uniq_args before func trmsp() called:['$uniq_args']'
uniq_args=$(trmsp $uniq_args)
echo '(trace):uniq_args after func trmsp() called:['$uniq_args']'

#todo: window position setting (minimize or maximize) based on file type or pass as args together with playback speed
local audio_only_flg=""
local wndw_pos=""
local audiofrmt="(mp3|flac|m4a|opus|aac|wav)"
local videofrmt="(mp4|mkv|webm|mpg|mpeg|m2ts|MTS|CPI|clpi|MPL|mpls|BDM|bdmv|rmvb|avi|dvi|ogg)"
#if [[ $* =~ mp3\|flac\|aac\|wav ]];then
if [[ $* =~ $audiofrmt ]];then
	audio_only_flg="--qt-start-minimized"
	echo "(trace):hit [[ $* =~ $audiofrmt ]]"
#elif [[ $* =~ mp4\|mkv\|webm\|mpg\|avi ]];then
elif [[ $* =~ $videofrmt ]];then
	#wndw_pos="--video-x 0 --video-y 0" #place VLC in top left corner
	echo "(trace):hit [[ $* =~ $videofrmt ]]"
#todo: return immediately when hit non-av file
#else
#	echo "error: invalid input files, please specify valid media files, and try again."
#	return 113
fi

nohup vlc --no-metadata-network-access --rate 1.3 --qt-start-minimized $uniq_args &> /dev/null & disown
#nohup vlc --no-metadata-network-access --rate 1.5 "$audio_only_flg" "$wndw_pos" $uniq_args &> /dev/null & disown
}

function vlopt() {
vlc --longhelp --advanced | less
}

function utup() {
setopt nocasematch
echo «$(\date +"%Y%m%d %H%M%S.%N%::z%Z %A")»
local return_code=113
local out_msg="error"
local err_counter=0
while (($return_code != 0)) || [[ $out_msg =~ error* ]];do #1.ERROR: can't find the current version. Please try again later. 2.Updating to version 2016.08.22 ...\nERROR: unable to download latest version (for error 2,better to detect network connection and return if connection lost)
#while (($return_code <> 0)) || [[ $out_msg =~ error ]];do #bad math expression: operand expected at `> 0'
	if ((err_counter++ > 9));then
		return 113
	fi
	out_msg=$(sudo youtube-dl -U)
	return_code=$?
	echo "(trace):err_counter:$err_counter"
	echo '(trace):regxpr:$match:['$match'],$MATCH:['$MATCH']'
	echo "(trace):youtube-dl -U:RC:$return_code"
	echo "(trace):youtube-dl -U:output message:$out_msg"
done
echo «$(\date +"%Y%m%d %H%M%S.%N%::z%Z %A")»
}

function fx() {
local uniq_args=$(gawk 'BEGIN {RS=ORS=" "} !seen[$1]++ {print $1}' <<< "$@")
echo '(trace):uniq_args before func trmsp() called:['$uniq_args']'
uniq_args=$(trmsp $uniq_args)
echo '(trace):uniq_args after func trmsp() called:['$uniq_args']'
nohup firefox --ssl-version-min=tls1.1 -private $uniq_args &> /dev/null & disown
}

function krm() {
local uniq_args=$(gawk 'BEGIN {RS=ORS=" "} !seen[$1]++ {print $1}' <<< "$@")
echo '(trace):uniq_args before func trmsp() called:['$uniq_args']'
uniq_args=$(trmsp $uniq_args)
echo '(trace):uniq_args after func trmsp() called:['$uniq_args']'
nohup google-chrome-stable --ssl-version-min=tls1.1 https://medium.com/@abhimuralidharan/functional-swift-all-about-closures-310bc8af31dd https://medium.com/@abhimuralidharan/higher-order-functions-in-swift-filter-map-reduce-flatmap-1837646a63e8 https://medium.com/@Dougly/higher-order-functions-in-swift-sorted-map-filter-reduce-dff60b5b6adf https://encrypted.google.com/search\?hl=en\&as_q=c%2B%2B+17+parse+command+line+arguments+as+float https://github.com/fffaraz/awesome-cpp https://gist.github.com/TSiege/cbb0507082bb18ff7e4b https://github.com/tommybennett/algorithm-mnemonics/blob/master/algorithm_mnemonics.xml https://encrypted.google.com/search\?hl=en\&q=c%2B%2B+input+sanitization https://encrypted.google.com/search\?hl=en\&q=c%2B%2B+macro https://github.com/ben-strasser/fast-cpp-csv-parser https://www.rosettacode.org/wiki/Web_scraping http://www.bfilipek.com/2014/12/top-5-beautiful-c-std-algorithms.html https://channel9.msdn.com/Events/GoingNative/2013/Cpp-Seasoning $uniq_args &> /dev/null & disown
# https://www.youtube.com/watch\?v=dN_gQYo9Uf8 https://www.youtube.com/watch\?v=5dJSZLmDsxk https://www.youtube.com/watch\?v=i-xqRDwpilM https://www.youtube.com/watch\?v=Az0J2UHbNCI https://www.youtube.com/watch\?v=WDn-htpBlnU
#https://encrypted.google.com/search\?hl=en\&as_q=bash+zsh+hashset+hashmap https://unix.stackexchange.com/questions/48505/how-to-make-sure-only-one-instance-of-a-bash-script-runs https://isocpp.org/faq https://encrypted.google.com/search\?hl=en\&as_q=python+3+book https://stackoverflow.com/questions/16807011/python-how-to-identify-if-a-variable-is-an-array-or-a-scalar http://bisqwit.iki.fi/ http://docs.python-guide.org/en/latest http://python-future.org/what_else.html#what-else https://dzone.com/articles/writing-a-web-service-using-python-flask https://www.reddit.com/r/learnpython/comments/264ffw/what_is_the_pythonic_way_of_storing_credentials https://docs.python.org/3/library/email.examples.html https://docs.python.org/2/library/email-examples.html https://stackoverflow.com/questions/34668240/email-an-attachment-with-non-ascii-filename-with-python-email https://developers.google.com/gmail/api/guides/sending https://encrypted.google.com/search\?hl=en\&as_q=programming+loop+unroll https://en.wikipedia.org/wiki/Loop_unrolling
#nohup google-chrome-stable --ssl-version-min=tls1.1 http://www.thechessdrum.net/chessacademy/index.html http://www.thechessdrum.net/65thSquare/65_janfeb04.html http://www.cppsamples.com http://docs.python-guide.org/en/latest https://github.com/line/line-bot-sdk-python http://python-future.org/automatic_conversion.html http://python-future.org/compatible_idioms.html#compatible-idioms http://python-future.org/what_else.html#what-else https://dzone.com/articles/writing-a-web-service-using-python-flask "$@" &> /dev/null & disown
}

function s0() {
if ((0 < $#));then
	#local uniq_args=$(gawk 'BEGIN {RS=ORS=" "} !seen[$1]++ {print $1}' <<< "$@")
	local uniq_args=$(gawk 'BEGIN {RS=" ";ORS="\n"} !seen[$1]++ {print $1}' <<< "$@")
	#https://stackoverflow.com/questions/15108229/how-to-count-number-of-words-from-string-using-shell
	#https://stackoverflow.com/questions/1469849/how-to-split-one-string-into-multiple-strings-separated-by-at-least-one-space-in
	#https://stackoverflow.com/questions/1975849/how-to-split-a-line-into-words-separated-by-one-or-more-spaces-in-bash
	echo '(trace):uniq_args before func trmsp() called:['$uniq_args']'
	uniq_args=$(trmsp $uniq_args)
	echo '(trace):uniq_args after func trmsp() called:['$uniq_args']'

	echo '${uniq_args[@]}:['${uniq_args[@]}']'
	echo '$uniq_args[@]:['$uniq_args[@]']'
	echo '${#uniq_args[@]}:['${#uniq_args[@]}']'
	echo '${uniq_args[@]:-1}:['${uniq_args[@]:-1}']'
	echo '$#':$#
	echo '$0:['$0']'

	local noNumber_rexpr="^[^0-9]*$"
	
	#https://stackoverflow.com/questions/1975849/how-to-split-a-line-into-words-separated-by-one-or-more-spaces-in-bash
	#use for value in "${var[@]}" in this context instead of an index variable. While in this case the array may be contiguous, Bash supports sparse arrays and ${#var[@]} may not be the last entry (although ${var[@]: -1} will be and indices=(${!a[@]}); count=${#indices[@]} will give the list of indices and the correct count)
	#local i=${#uniq_args[@]} #wrong! 90 -> [9] [0] -> take 0 and shutdown immediately!
	#local i=$#
	#for ((; 0 < i; --i));do
	#todo: Failed to parse time specification: 99 50 a
#http://www.refining-linux.org/archives/38/ZSH-Gem-3-No-automatic-word-split/
setopt sh_word_split
setopt SH_WORD_SPLIT
	#local IFS=' '
	local IFS=$'\n'
	#todo: backward for-each
	for tm in $uniq_args;do
		#if [[ $i =~ [0-9]+ ]];then
		if [[ ! $tm =~ $noNumber_rexpr ]];then
			#echo 'sudo shutdown -P -f ${uniq_args[i]}:['${uniq_args[i]}']'
			#sudo shutdown -P -f ${uniq_args[i]}
			#echo 'sudo shutdown -P -f $i:['$i']'
			#sudo shutdown -P -f $i
			echo 'sudo shutdown -P -f $tm:['$tm']'
			sudo shutdown -P -f $tm
			break
		fi
	done
unsetopt sh_word_split
unsetopt SH_WORD_SPLIT
else
	sudo shutdown -P -f 0
fi
}

function ss() {
#trap on EXIT, that way, time(s) will be called whenever the shell exits and the exit status will be preserved.
#http://unix.stackexchange.com/questions/52313/how-to-get-execution-time-of-a-script-effectively
trap time EXIT
echo «$(\date +"%Y%m%d %H%M%S.%N%::z%Z %A")»
#todo: detect OS
#sudo apt update && sudo apt upgrade -y
#Skipping packages with conflicts: (add '--best --allowerasing' to command line to force their upgrade)
sudo dnf upgrade --best --allowerasing -y
echo '$?':$?
#youtube-dl upgrade
utup
echo '$?':$?
}

function detectOS() {
#todo: detect OS(Ubuntu, Debian, Mint, kali, RHEL, Centos, Fedora, Suse, etc.)
#https://github.com/dmytro/sherlock_os/blob/master/bin/sherlock
#https://danielgibbs.co.uk/2013/04/bash-how-to-detect-os/
local arch=$(uname -m)
local kernel=$(uname -r)
local distroname=""
if [ -n "$(command -v lsb_release)" ]; then
	distroname=$(lsb_release -s -d)
elif [ -f "/etc/os-release" ]; then
	distroname=$(grep PRETTY_NAME /etc/os-release | sed 's/PRETTY_NAME=//g' | tr -d '="')
elif [ -f "/etc/debian_version" ]; then
	distroname="Debian $(cat /etc/debian_version)"
elif [ -f "/etc/redhat-release" ]; then
	distroname=$(cat /etc/redhat-release)
else
	distroname="$(uname -s) $(uname -r)"
fi
echo "(trace):distroname:${distroname}"
}

function putfio() {
if (($# == 1));then
	curl -F "file=@$1" 'https://file.io/?expires=3d'
	echo '$?':$?
elif (($# == 2)) && [[ $2 =~ [1-9][0-9]{0,2}[dmwDMW] ]];then
	echo '(trace): =~ [1-9][0-9]{0,2}[dmwDMW] :$MATCH:['$MATCH'],array $match:['$match']'
	curl -F "file=@$1" "https://file.io/?expires=$2"
	echo '$?':$?
else
	echo "usage: putfio <id> [(expires=)<9d/3m/7w>]"
#define EX_USAGE 64 /* command line usage error */
	return 64
fi
}

function getfio() {
if (($# == 2));then
	curl -o "$2.7z" "https://file.io/$1"
	echo '$?':$?
elif (($# == 1));then
	curl -o "$1.7z" "https://file.io/$1"
	echo '$?':$?
else
	echo "usage: getfio <id> [output_file_name_without_suffix]"
#define EX_USAGE 64 /* command line usage error */
	return 64
fi
}

function srv() {
#detect OS(Ubuntu, Debian, Mint, kali, RHEL, Centos, Fedora, Suse, etc.)

if (($# == 2));then
	if [[ "$1" == status ]];then
		sudo systemctl -al status "$2"
	fi
		sudo systemctl "$1" "$2"
fi
echo '$?':$?
#apache2, same for httpd
#alias apstt='sudo systemctl -l status apache2'
#alias apstp='sudo systemctl stop apache2'
#alias apstr='sudo systemctl start apache2'
#alias aprst='sudo systemctl restart apache2'
#alias aprld='sudo systemctl reload apache2'

#alias apstt='sudo /etc/init.d/apache2 status'
#alias apstp='sudo /etc/init.d/apache2 graceful-stop'
#alias apstr='sudo /etc/init.d/apache2 start'
#alias aprst='sudo /etc/init.d/apache2 restart'
#alias aprld='sudo /etc/init.d/apache2 reload'

#mysql, mariadb
#alias mystt='sudo systemctl -a status mysql'
#alias mystp='sudo systemctl stop mysql'
#alias mystr='sudo systemctl start mysql'
#alias myrst='sudo systemctl restart mysql'
}

function srvstr() {
local uniq_args=$(gawk -v quot="'" 'BEGIN {RS=" ";ORS="\n"} !seen[$1]++ {printf "%s%s%s\n", quot, $1, quot}' <<< "$@")
echo '(trace):uniq_args before func trmsp() called:['$uniq_args']'
uniq_args=$(trmsp $uniq_args)
echo '(trace):uniq_args after func trmsp() called:['$uniq_args']'
local srv=""
for srv in $uniq_args;do
	sudo service "$srv" start
	echo '$?':$?
done
}

function srvstp() {
local uniq_args=$(gawk -v quot="'" 'BEGIN {RS=" ";ORS="\n"} !seen[$1]++ {printf "%s%s%s\n", quot, $1, quot}' <<< "$@")
echo '(trace):uniq_args before func trmsp() called:['$uniq_args']'
uniq_args=$(trmsp $uniq_args)
echo '(trace):uniq_args after func trmsp() called:['$uniq_args']'
local srv=""
for srv in $uniq_args;do
	sudo service "$srv" stop
	echo '$?':$?
done
}

#weather
function wttr() {
if ((0 < $#));then
	local uniq_args=$(gawk 'BEGIN {RS=" ";ORS="\n"} !seen[$1]++ {print $1}' <<< "$@")
	echo '(trace):uniq_args before func trmsp() called:['$uniq_args']'
	uniq_args=$(trmsp $uniq_args)
	echo '(trace):uniq_args after func trmsp() called:['$uniq_args']'

	local arg=""
	for arg in $uniq_args;do
		if [[ $arg =~ [a-zA-Z0-9.]*[a-zA-Z]+ ]];then
			curl wttr.in/@$arg
		elif [[ $arg =~ [a-zA-Z0-9]* ]];then
			curl wttr.in/$arg
		elif [[ $arg =~ [/-]h ]];then
			curl wttr.in/:help
		fi
		echo '$?':$?
	done
else
	curl wttr.in
	echo '$?':$?
fi
}

#primitive ffmpeg av rewind fast-forward
function avrwndff() {
if (($# < 1 || $# > 3)) || (($# == 3)) && [[ ! ($2 =~ ^[-+]?[0-9]?[.,]?[1-9]{1,2}$) ]];then	# { (($# == 3)) && [[ ! ($2 =~ ^[-+]?[0-9]?[.,]?[1-9]{1,2}$) ]] }?	http://unix.stackexchange.com/questions/88850/precedence-of-the-shell-logical-operators
	if (($# == 3)) && [[ ! ($2 =~ ^[-+]?[0-9]?[.,]?[1-9]{1,2}$) ]];then
		echo '※(trace):hit "...|| (($# == 3)) && [[ ! ($2 =~ ^[-+]?[0-9]?[.,]?[1-9]{1,2}$) ]]" #better { (($# == 3)) && [[ ! ($2 =~ ^[-+]?[0-9]?[.,]?[1-9]{1,2}$) ]] }?'
	fi
	echo "(trace):usage: avrwndff input_file [(optional)speed factor(2.0(default) 1.75 2.25 2.5...)] [(optional)output file name prefix]"
#define EX_USAGE 64 /* command line usage error */
	return 64
fi

echo '$#':$#
local idx=0
local arg=""
for arg in "$@";do
	echo '$'$((++idx)):'['$arg']'
done

local infile=""
local outfile=""
local factor=""

if [[ ! -f $1 ]];then
	echo "(trace):please specify a valid local file name, and try again."
	return 113
else
	infile="$1"
	if (($# == 1));then
		factor="2"	#default
		outfile="${infile%.*}"
		outfile+="_spdx"
		outfile+=$factor
		outfile+="."
		suffix="${infile##*.}"
		outfile+=$suffix
	fi
fi

if (($# == 2));then
#if [[ $2 =~ (^[-+]?[0-9]?[.,][1-9]{1,2}$)|(^[-+]?[1-9]$) ]];then #parse error near `|'
	if [[ $2 =~ ^[-+]?[0-9]?[.,]?[1-9]{1,2}$ ]];then #http://www.regular-expressions.info/floatingpoint.html
		echo '(trace):hit [[ $2 =~ ^[-+]?[0-9]?[.,]?[1-9]{1,2}$ ]]'
		factor="$2"
		outfile="${infile%.*}"
		outfile+="_spdx"
		outfile+=$factor
		outfile+="."
		suffix="${infile##*.}"
		outfile+=$suffix
	elif [[ -e $2 ]];then
		echo "(trace):error: destination/output file already exist, please specify other name for output, and try again."
		return 113
	else
		outfile="$2"
		outfile+="_spdx"
		factor="2"	#default
		outfile+=$factor
		outfile+="."
		suffix="${infile##*.}"
		outfile+=$suffix
	fi
fi

if (($# == 3));then
#if [[ $2 =~ (^[-+]?[0-9]?[.,][1-9]{1,2}$)|(^[-+]?[1-9]$) ]];then #parse error near `|'
	if [[ $2 =~ ^[-+]?[0-9]?[.,]?[1-9]{1,2}$ ]];then
		if [[ -e $3 ]];then
			echo "(trace):error: destination/output file already exist, please specify other name for output, and try again."
			return 113
		fi
		echo '(trace):hit [[ $2 =~ ^[-+]?[0-9]?[.,]?[1-9]{1,2}$ ]]'
		factor="$2"
		outfile="$3"
		outfile+="_spdx"
		outfile+=$factor
		outfile+="."
		suffix="${infile##*.}"
		outfile+=$suffix
	else	#? redundant as already checked at function start
		echo "(trace):usage: avrwndff input_file [(optional)speed factor(2.0(default) 1.75 2.25 2.5...)] [(optional)output file name prefix]"
		#define EX_USAGE 64 /* command line usage error */
		return 64
	fi
fi

echo "(trace):#test<"
if (($# == 2)) && [[ $2 == ^[-+]?[0-9]?[.,]?[1-9]{1,2}$ ]];then
	echo '(trace):hit (($# == 2)) && [[ $2 == ^[-+]?[0-9]?[.,]?[1-9]{1,2}$ ]]'
fi

# [[ != ]] literal string comparison?
if (($# == 2)) && [[ $2 != ^[-+]?[0-9]?[.,]?[1-9]{1,2}$ ]];then
	echo '(trace):ERRONEOUS/WRONG! hit (($# == 2)) && [[ $2 != ^[-+]?[0-9]?[.,]?[1-9]{1,2}$ ]], [[ != ]] literal string comparison?'
fi

if (($# == 2)) && [[ ! ($2 =~ ^[-+]?[0-9]?[.,]?[1-9]{1,2}$) ]];then
	echo '(trace):hit (($# == 2)) && [[ ! ($2 =~ ^[-+]?[0-9]?[.,]?[1-9]{1,2}$) ]] #"[[ ! (xpr) ]]'
fi

if (($# == 2)) && [[ ! ( $2 =~ ^[-+]?[0-9]?[.,]?[1-9]{1,2}$ ) ]];then
	echo '(trace):hit (($# == 2)) && [[ ! ( $2 =~ ^[-+]?[0-9]?[.,]?[1-9]{1,2}$ ) ]] #"[[ ! ( xpr ) ]]'
fi
echo "(trace):#test>"

#http://unix.stackexchange.com/questions/131766/why-does-my-shell-script-choke-on-whitespace-or-other-special-characters
#infile_singlequoted=$(printf %s. "$infile" | sed "s/'/'\\\\''/g")
#outfile_singlequoted=$(printf %s. "$outfile" | sed "s/'/'\\\\''/g")

#'How'\''s Do One-Way Mirrors Work-4kKL32opewI.mp4' #output by ll on Fedora24+

local infile_singlequoted=$(printf \'%s\' "$(printf %s "$infile" | sed "s/'/'\\\\''/g")")
local outfile_singlequoted=$(printf \'%s\' "$(printf %s "$outfile" | sed "s/'/'\\\\''/g")")
echo '(trace):"${infile_singlequoted}"':"${infile_singlequoted}"
echo '(trace):"${outfile_singlequoted}"':"${outfile_singlequoted}"

if [[ -e ${outfile_singlequoted} ]];then
	echo "(trace):error: destination/output file already exist, please specify other name for output, and try again."
	return 113
fi

local cmd='ffmpeg -i '
cmd+="${infile_singlequoted}" #"$infile_singlequoted"
cmd+=' -filter:v "setpts=PTS/'
cmd+=$factor
cmd+='" -filter:a "atempo='
cmd+=$factor
cmd+='" '
cmd+="${outfile_singlequoted}" #"$outfile_singlequoted"

#cmd=${cmd//\'/\\\'} #eval: unmatched '
#cmd=${cmd//*/\*}

echo '(trace):$cmd:['$cmd']'
eval " $cmd"
echo '$?':$?
}

function appvr() {
uname -a
vim --version
nvim --version
gdb --version
gcc --version
g++ --version
git --version
as --version	#GNU assembler
openssl version
ssh -V
libreoffice --version
ffmpeg -version
gimp --version
vlc --version
google-chrome-stable --version
xmllint --version
echo "(trace):node --version":$(node --version)
echo "(trace):youtube-dl --version":$(youtube-dl --version)
#echo "python --version":$(python --version) #python outputs its name automatically!
echo $(python --version)	#'echo' spaces with an empty line
perl --version
}

# ≈ MS Word
function wrtr() {
local uniq_args=$(gawk 'BEGIN {RS=" ";ORS="\n"} !seen[$1]++ {print $1}' <<< "$@")
echo '(trace):uniq_args before func trmsp() called:['$uniq_args']'
uniq_args=$(trmsp $uniq_args)
echo '(trace):uniq_args after func trmsp() called:['$uniq_args']'
local args=""
local file=""
for file in $uniq_args;do
	if [[ -d $file ]];then
		echo "error: directory with name \`$file' already exist, unable to edit directories, please specify other file name, and try again."
		return 113
	elif [[ ! -e $file ]];then
		touch $file
	fi
	
	args+="$file "
done
args=${args%% }
nohup libreoffice --writer $args &> /dev/null & disown
}

function sprsht() {
#local uniq_args=$(gawk 'BEGIN {RS=ORS="\n"} !seen[$0]++ {print $0}' <<< "$@")
local uniq_args=$(gawk 'BEGIN {RS=ORS=" "} !seen[$1]++ {print $1}' <<< "$@")
echo '(trace):uniq_args before func trmsp() called:['$uniq_args']'
uniq_args=$(trmsp $uniq_args)
echo '(trace):uniq_args after func trmsp() called:['$uniq_args']'
nohup libreoffice --calc $uniq_args &> /dev/null & disown
}

# ≈ MS Powerpoint
function slid() {
#local uniq_args=$(gawk 'BEGIN {RS=ORS="\n"} !seen[$0]++ {print $0}' <<< "$@")
local uniq_args=$(gawk 'BEGIN {RS=ORS=" "} !seen[$1]++ {print $1}' <<< "$@")
echo '(trace):uniq_args before func trmsp() called:['$uniq_args']'
uniq_args=$(trmsp $uniq_args)
echo '(trace):uniq_args after func trmsp() called:['$uniq_args']'
nohup libreoffice --impress $uniq_args &> /dev/null & disown
}

#view pdf
function vns() {
local uniq_args=$(gawk 'BEGIN {RS=ORS=" "} !seen[$1]++ {print $1}' <<< "$@")
echo '(trace):uniq_args before func trmsp() called:['$uniq_args']'
uniq_args=$(trmsp $uniq_args)
echo '(trace):uniq_args after func trmsp() called:['$uniq_args']'
nohup evince $uniq_args &> /dev/null & disown
}

function mkcd() {
if [[ -z $1 ]] || [[ ! -n $1 ]];then
	echo "error: please specify a valid directory name and try again."
	return 113
elif [[ -d $1 ]];then
	echo "error: destination directory \`$1' already exist, please specify other name and try again."
	return 113
else
	mkdir -p -- "$1" &&
	cd -P -- "$1"
	#BASH BUILTIN COMMANDS
	#Unless otherwise noted, each builtin command documented in this section as accepting options preceded by - accepts -- to signify the end of the options.
	#mkdir -p "$1" &&
	#cd "$1"	#cd: line number : no such file or directory
	echo '$?':$?
	echo 'pwd':$(pwd)
fi
}

function skrsht() {
if ((1 == $#)) && [[ ! -d $1 ]];then
#	scrot -q 100 -d 5 -c -s "$1"	#faulty
	gnome-screenshot -w -p -d 5 -f "$1"
	echo '$?':$?
	nohup eog "$1" &> /dev/null & disown
else
#	scrot -q 100 -d 5 -c -s -e 'eog $f'	#faulty
	filename=$(\date +"%Y%m%d%H%M%S%::z").jpg
	gnome-screenshot -w -p -d 5 -f "$HOME/$filename"
	echo '$?':$?
	nohup eog "$HOME/$filename" &> /dev/null & disown
fi
}

function klam() {
sudo freshclam;sudo clamscan --exclude-dir='^/sys' -i --bell -r /;echo '$?':$?
#nohup "sudo freshclam;sudo clamscan --exclude-dir='^/sys' -i --bell -r / &> ~/.klam & disown;echo '$?':$?
}

function blutu0() {
sudo systemctl stop bluetooth.service
sudo systemctl disable bluetooth.service
sudo systemctl status bluetooth.service
echo '$?':$?
}

function volut() {
nohup evolution &> /dev/null & disown
}

function zrcdf() {
diff ~/.zsh-func /mnt/0/gthb/xrcs/.zsh-func
echo ------
diff ~/.zshrc /mnt/0/gthb/xrcs/.zshrc
}

function psgt() {
local curdir="$PWD"
local gthbdir="/mnt/0/gthb"
local saveIFS="$IFS"
echo '(trace):original/default $IFS:['$IFS']'
local IFS=" " gthbRepodirs=("xrcs" "note")
#https://stackoverflow.com/questions/18383291/loop-over-set-of-strings-containing-spaces
#https://superuser.com/questions/781766/ifs-separated-items-in-loop
#https://unix.stackexchange.com/questions/131766/why-does-my-shell-script-choke-on-whitespace-or-other-special-characters
echo '(trace):temporarily set $IFS:['$IFS']'
IFS="$saveIFS"
local repo=""
for repo in "${gthbRepodirs[@]}";do cd $gthbdir/$repo && (echo '$PWD':$PWD ; git push origin $(git_current_branch));done
cd $curdir
echo '$?':$?
}

function swpfile() {
#if [[ $# -ne 2 ]];then
if (( $# != 2 ));then
  echo "(trace):Syntax: $(basename $0) <FILE 1> <FILE 2>"
  return -1
fi

if [[ ! -f $1 ]]; then
  echo "(trace):File \`$1' does not exist!"
  return -1
fi

if [[ ! -f $2 ]]; then
  echo "(trace):File \`$2' does not exist!"
  return -1
fi

#https://stackoverflow.com/questions/1115904/shortest-way-to-swap-two-files-in-bash
#⓪
#local TMPFILE=tmp.$$
#mv "$1" $TMPFILE && mv "$2" "$1" && mv $TMPFILE $2

#①
local tmpfile=$(mktemp $(dirname "$1")/_XXXXXX_)
if [[ ! -f $tmpfile ]]; then
  echo "(trace):Could not create temporary intermediate file!"
  return -1
fi

command mv -f "$1" "$tmpfile" && mv -f "$2" "$1" && mv -f "$tmpfile" "$2"
echo '$?':$?
}

#https://stackoverflow.com/questions/369758/how-to-trim-whitespace-from-a-bash-variable
function trmsp() {
    local var="$*"
    # remove leading whitespace characters
    var="${var#"${var%%[![:space:]]*}"}"
    # remove trailing whitespace characters
    var="${var%"${var##*[![:space:]]}"}"   
    echo -n "$var"
}

#get space separated uniq args
function uniksp() {
	local uniq_args=$(gawk 'BEGIN {RS=ORS=" "} !seen[$1]++ {print $1}' <<< "$@")
	echo '(trace):uniq_args before func trmsp() called:['$uniq_args']'
	uniq_args=$(trmsp $uniq_args)
	echo '(trace):uniq_args after func trmsp() called:['$uniq_args']'
	return $uniq_args
}

#get newline separated uniq args
function uniklb() {
	local uniq_args=$(gawk 'BEGIN {RS=" ";ORS="\n"} !seen[$1]++ {print $1}' <<< "$@")
	echo '(trace):uniq_args before func trmsp() called:['$uniq_args']'
	uniq_args=$(trmsp $uniq_args)
	echo '(trace):uniq_args after func trmsp() called:['$uniq_args']'
	return $uniq_args
}

function prntenv() {
	echo 'function prntenv:(Env):$SHELL':$SHELL';$shell':$shell
	echo 'function prntenv:(Env):$IFS:['$IFS']'
}

function 2locase() {
if (($# > 0));then
	#local uniq_args=$(gawk 'BEGIN {RS=ORS=" "} !seen[$1]++ {printf "%s ", $1}' <<< "$@")
	local uniq_args=$(gawk 'BEGIN {RS=ORS=" "} !seen[$1]++ {print $1}' <<< "$@")
	echo '(trace):uniq_args before func trmsp() called:['$uniq_args']'
	uniq_args=$(trmsp $uniq_args)
	echo '(trace):uniq_args after func trmsp() called:['$uniq_args']'
	echo $uniq_args | tr '[:upper:]' '[:lower:]'
	echo '$?':$?
fi
}

function 2upcase() {
if (($# > 0));then
	#local uniq_args=$(gawk 'BEGIN {RS=ORS=" "} !seen[$1]++ {printf "%s ", $1}' <<< "$@")
	local uniq_args=$(gawk 'BEGIN {RS=ORS=" "} !seen[$1]++ {print $1}' <<< "$@")
	echo '(trace):uniq_args before func trmsp() called:['$uniq_args']'
	uniq_args=$(trmsp $uniq_args)
	echo '(trace):uniq_args after func trmsp() called:['$uniq_args']'
	echo $uniq_args | tr '[:lower:]' '[:upper:]'
	echo '$?':$?
fi
}

#todo
#erroneous
#Shift JIS to utf8
function sjis2utf8() {
if (($# == 1));then
	local basename=${1%\.*}
	local extension=${1##*\.}
	echo 'file base name:${file%\.*}':$basename
	echo 'file extension:${file##*\.}':$extension
	iconv -f shift-JIS -t utf8 "$1" > "${basename}_utf8.${extension}"
#	iconv -f SHIFT-JIS -t UTF-8 "$1" > "${basename}_UTF-8.${extension}"
#	iconv -f shift-JIS -t utf-8 "$1" > "${basename}_utf-8.${extension}"
	echo '$?':$?
fi
}

#erroneous
function urlencode() {
# urlencode <string>
local old_lc_collate=$LC_COLLATE
local LC_COLLATE=C

local length="${#1}"
local i=0 
for (( i = 0; i < length; ++i ));do
	local c="${1:i:1}"
	case $c in
		[a-zA-Z0-9.~_-]) printf "$c" ;;
		*) printf '%%%02X' "'$c" ;;
	esac
done
echo '$?':$?
LC_COLLATE=$old_lc_collate
}

#erroneous
function urldecode() {
# urldecode <string>
local url_encoded="${1//+/ }"
printf '%b' "${url_encoded//%/\\x}"
echo '$?':$?
}

#erroneous
function scrblk() {
dbus-send --type=method_call --dest=org.gnome.ScreenSaver /org/gnome/ScreenSaver org.gnome.ScreenSaver.Lock
#xset dpms force off
}

